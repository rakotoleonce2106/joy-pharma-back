name: Deploy - Server Deployment

on:
  workflow_call:
    inputs:
      image-tag:
        description: "Docker image tag to deploy"
        required: false
        type: string
        default: preprod
  workflow_dispatch:
    inputs:
      image-tag:
        description: "Docker image tag to deploy"
        required: false
        type: string
        default: preprod

jobs:
  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Copy Docker configuration to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          source: "compose.yaml,compose.prod.yaml,frankenphp,scripts"
          target: "joypharma/"
          overwrite: true

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          timeout: 60s
          command_timeout: 15m
          script: |
            set -e
            cd joypharma
            
            # Login to Docker Hub
            echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin

            # Determine the image tag to use
            IMAGE_TAG="${{ inputs.image-tag }}"
            if [ -z "$IMAGE_TAG" ]; then
              IMAGE_TAG="preprod"
            fi
            
            export IMAGE_NAME="${{ secrets.DOCKERHUB_USERNAME }}/joy-pharma-back:${IMAGE_TAG}"
            export IMAGES_PREFIX="${{ secrets.DOCKERHUB_USERNAME }}/"
            
            # Find Traefik network
            # Try multiple methods to find Traefik network
            TRAEFIK_NETWORK=""
            
            # Method 1: Check if Traefik container exists and get its network
            if docker ps -a --format '{{.Names}}' | grep -q "^traefik$"; then
                TRAEFIK_NETWORK=$(docker inspect traefik --format '{{range $net, $conf := .NetworkSettings.Networks}}{{$net}}{{end}}' 2>/dev/null | head -n1)
            fi
            
            # Method 2: Look for common Traefik network names
            if [ -z "$TRAEFIK_NETWORK" ]; then
                for NET_NAME in traefik traefik_default traefik_proxy; do
                    if docker network inspect "$NET_NAME" &>/dev/null; then
                        TRAEFIK_NETWORK="$NET_NAME"
                        break
                    fi
                done
            fi
            
            # Method 3: Check networks with "traefik" in the name
            if [ -z "$TRAEFIK_NETWORK" ]; then
                TRAEFIK_NETWORK=$(docker network ls --format '{{.Name}}' | grep -i traefik | head -n1)
            fi
            
            if [ -z "$TRAEFIK_NETWORK" ]; then
                NETWORK_NAME="joy-pharma-back_default"
                if ! docker network inspect $NETWORK_NAME &>/dev/null; then
                    docker network create $NETWORK_NAME
                fi
                export TRAEFIK_NETWORK=$NETWORK_NAME
            else
                export TRAEFIK_NETWORK
            fi
            
            # Verify network exists
            if ! docker network inspect "$TRAEFIK_NETWORK" &>/dev/null; then
                exit 1
            fi
            
            # Install Infisical CLI on the server
            if ! command -v infisical &> /dev/null; then
                curl -1sLf 'https://dl.cloudsmith.io/public/infisical/infisical-cli/setup.deb.sh' | sudo -E bash
                sudo apt-get update && sudo apt-get install -y infisical
            fi
            
            # Generate .env file using Infisical
            INFISICAL_TOKEN=$(infisical login --method=universal-auth --client-id="${{ secrets.INFISICAL_CLIENT_ID }}" --client-secret="${{ secrets.INFISICAL_CLIENT_SECRET }}" --domain="${{ secrets.INFISICAL_DOMAIN }}" --silent --plain)
            
            if [ -z "$INFISICAL_TOKEN" ]; then
                exit 1
            fi
            
            # Export environment variables to .env file
            infisical export --token=$INFISICAL_TOKEN --domain="${{ secrets.INFISICAL_DOMAIN }}" --projectId="${{ secrets.INFISICAL_PROJECTID }}" --env=prod --format=dotenv > .env
            
            if [ ! -s .env ]; then
                exit 1
            fi
            
            # Add Docker-specific variables to .env
            echo "" >> .env
            echo "# Docker Configuration" >> .env
            echo "INFISICAL_TOKEN=$INFISICAL_TOKEN" >> .env
            echo "INFISICAL_PROJECT_ID=${{ secrets.INFISICAL_PROJECTID }}" >> .env
            echo "IMAGES_PREFIX=${{ secrets.DOCKERHUB_USERNAME }}/" >> .env
            echo "IMAGE_TAG=${IMAGE_TAG}" >> .env
            echo "TRAEFIK_NETWORK=$TRAEFIK_NETWORK" >> .env
            
            # Ensure critical Symfony/FrankenPHP variables are set
            if ! grep -q "^APP_ENV=" .env; then
                echo "APP_ENV=prod" >> .env
            fi
            
            if ! grep -q "^SERVER_NAME=" .env; then
                echo "SERVER_NAME=${{ secrets.SERVER_NAME }}" >> .env
            fi
            
            # Export variables for docker compose commands (as backup)
            export INFISICAL_TOKEN
            export INFISICAL_PROJECT_ID="${{ secrets.INFISICAL_PROJECTID }}"
            export IMAGE_NAME
            export TRAEFIK_NETWORK
            
            if [ ! -f .env ]; then
                exit 1
            fi
            
            # Verify compose files are present and correct
            if [ ! -f compose.yaml ]; then
                exit 1
            fi
            if [ ! -f compose.prod.yaml ]; then
                exit 1
            fi
            
            # Backup current container for rollback
            if [ -f compose.yaml ] && [ -f .env ]; then
                CURRENT_CONTAINER=$(docker compose -f compose.yaml -f compose.prod.yaml --env-file .env ps -q php 2>/dev/null || echo "")
            else
                CURRENT_CONTAINER=""
            fi
            
            # Pull new images with retry logic
            MAX_RETRIES=3
            RETRY_COUNT=0
            until docker compose -f compose.yaml -f compose.prod.yaml --env-file .env pull || [ $RETRY_COUNT -eq $MAX_RETRIES ]; do
                RETRY_COUNT=$((RETRY_COUNT+1))
                sleep 5
            done
            
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                exit 1
            fi
            
            # Stop existing containers to free ports (especially port 80)
            docker compose -f compose.yaml -f compose.prod.yaml --env-file .env down 2>/dev/null || true
            
            # Find and remove containers with conflicting Traefik labels (joy-pharma-back router)
            CONFLICTING_CONTAINERS=$(docker ps -a --format "{{.ID}}\t{{.Names}}" | while read id name; do
                if docker inspect "$id" --format '{{range $k, $v := .Config.Labels}}{{$k}}={{$v}}{{"\n"}}{{end}}' 2>/dev/null | grep -q "traefik.http.routers.joy-pharma-back"; then
                    echo "$id"
                fi
            done)
            
            if [ -n "$CONFLICTING_CONTAINERS" ]; then
                echo "$CONFLICTING_CONTAINERS" | xargs -r docker stop 2>/dev/null || true
                echo "$CONFLICTING_CONTAINERS" | xargs -r docker rm 2>/dev/null || true
            fi
            
            # Also stop any containers that might be using port 80
            CONTAINERS_ON_80=$(docker ps --filter "publish=80" --format "{{.ID}}" 2>/dev/null || echo "")
            if [ -n "$CONTAINERS_ON_80" ]; then
                echo "$CONTAINERS_ON_80" | xargs -r docker stop 2>/dev/null || true
            fi
            
            # Remove container with fixed name if it exists (to avoid name conflicts)
            if docker ps -a --filter "name=^joy-pharma-back-php$" --format "{{.ID}}" | grep -q .; then
                docker stop joy-pharma-back-php 2>/dev/null || true
                docker rm joy-pharma-back-php 2>/dev/null || true
            fi
            
            # Check for any containers with name containing joypharma or joy-pharma-back
            REMAINING_CONTAINERS=$(docker ps -a --filter "name=joypharma" --format "{{.ID}}" 2>/dev/null || echo "")
            REMAINING_CONTAINERS="$REMAINING_CONTAINERS $(docker ps -a --filter "name=joy-pharma-back" --format "{{.ID}}" 2>/dev/null || echo "")"
            if [ -n "$REMAINING_CONTAINERS" ]; then
                echo "$REMAINING_CONTAINERS" | xargs -r docker stop 2>/dev/null || true
                echo "$REMAINING_CONTAINERS" | xargs -r docker rm 2>/dev/null || true
            fi
            
            # Wait a moment for ports to be released
            sleep 3
            
            # Verify port 80 is free
            if command -v lsof >/dev/null 2>&1; then
                PORT_80_USERS=$(lsof -i :80 2>/dev/null | wc -l || echo "0")
                if [ "$PORT_80_USERS" -gt "0" ]; then
                    lsof -i :80 2>/dev/null || true
                    docker ps --filter "publish=80" --format "{{.ID}}" | xargs -r docker stop 2>/dev/null || true
                    docker ps --filter "publish=80" --format "{{.ID}}" | xargs -r docker rm 2>/dev/null || true
                    sleep 2
                fi
            fi
            
            # Deploy new version
            if docker compose -f compose.yaml -f compose.prod.yaml --env-file .env up -d; then
                # Wait for services to stabilize
                sleep 10
                
                # Check all services
                docker compose -f compose.yaml -f compose.prod.yaml --env-file .env ps
                
                # Get container IDs
                PHP_CONTAINER=$(docker compose -f compose.yaml -f compose.prod.yaml --env-file .env ps -q php 2>/dev/null || echo "")
                DB_CONTAINER=$(docker compose -f compose.yaml -f compose.prod.yaml --env-file .env ps -q database 2>/dev/null || echo "")
                
                if [ -z "$PHP_CONTAINER" ]; then
                    docker compose -f compose.yaml -f compose.prod.yaml --env-file .env logs php
                    exit 1
                fi
                
                # Check PHP container status
                sleep 5
                CONTAINER_STATUS=$(docker inspect --format='{{.State.Status}}' $PHP_CONTAINER 2>/dev/null || echo "unknown")
                RESTART_COUNT=$(docker inspect --format='{{.RestartCount}}' $PHP_CONTAINER 2>/dev/null || echo "0")
                
                if [ "$CONTAINER_STATUS" = "running" ] && [ "$RESTART_COUNT" = "0" ]; then
                    # Wait for database to be ready
                    MAX_DB_WAIT=30
                    DB_WAIT=0
                    until docker compose -f compose.yaml -f compose.prod.yaml --env-file .env exec -T database pg_isready -U app 2>/dev/null || [ $DB_WAIT -eq $MAX_DB_WAIT ]; do
                        DB_WAIT=$((DB_WAIT+1))
                        sleep 2
                    done
                    
                    if [ $DB_WAIT -ne $MAX_DB_WAIT ]; then
                        # Generate JWT keys with real secrets from Infisical
                        docker compose -f compose.yaml -f compose.prod.yaml --env-file .env exec -T php bin/console lexik:jwt:generate-keypair --overwrite --no-interaction || true
                        
                        # Run migrations (CRITICAL - must succeed)
                        
                        # Verify PHP container is ready
                        if ! docker compose -f compose.yaml -f compose.prod.yaml --env-file .env exec -T php php -v > /dev/null 2>&1; then
                            docker compose -f compose.yaml -f compose.prod.yaml --env-file .env logs php --tail 50
                            exit 1
                        fi
                        
                        # Verify database connection before migrations
                        if ! docker compose -f compose.yaml -f compose.prod.yaml --env-file .env exec -T php bin/console dbal:run-sql "SELECT 1" > /dev/null 2>&1; then
                            exit 1
                        fi
                        
                        # First, ensure migration metadata storage is synchronized (creates table if needed)
                        SYNC_OUTPUT=$(docker compose -f compose.yaml -f compose.prod.yaml --env-file .env exec -T php bin/console doctrine:migrations:sync-metadata-storage --no-interaction 2>&1 || echo "")
                        SYNC_EXIT_CODE=$?
                        if [ $SYNC_EXIT_CODE -ne 0 ] && ! echo "$SYNC_OUTPUT" | grep -qi "already synchronized"; then
                            true
                        fi
                        
                        # Check migration status first to see what we're dealing with
                        MIGRATION_STATUS=$(docker compose -f compose.yaml -f compose.prod.yaml --env-file .env exec -T php bin/console doctrine:migrations:status --no-interaction 2>&1 || echo "")
                        echo "$MIGRATION_STATUS" | head -20 || true
                        
                        # Now execute migrations and capture output
                        MIGRATION_OUTPUT=$(docker compose -f compose.yaml -f compose.prod.yaml --env-file .env exec -T php bin/console doctrine:migrations:migrate --no-interaction 2>&1)
                        MIGRATION_EXIT_CODE=$?
                        
                        if [ $MIGRATION_EXIT_CODE -eq 0 ]; then
                            # Show what was executed
                            if echo "$MIGRATION_OUTPUT" | grep -q "migrated"; then
                                echo "$MIGRATION_OUTPUT" | grep -E "(migrated|Executing)" || true
                            fi
                        else
                            # Check if error is just "no registered migrations" which is OK for first deployment
                            if echo "$MIGRATION_OUTPUT" | grep -qi "no registered migrations" || \
                               echo "$MIGRATION_OUTPUT" | grep -qi "couldn't be reached" || \
                               echo "$MIGRATION_OUTPUT" | grep -qi "already at latest version" || \
                               echo "$MIGRATION_OUTPUT" | grep -qi "nothing to migrate" || \
                               echo "$MIGRATION_OUTPUT" | grep -qi "already synchronized"; then
                                true
                            else
                                echo "$MIGRATION_OUTPUT"
                                echo "$MIGRATION_STATUS"
                                docker compose -f compose.yaml -f compose.prod.yaml --env-file .env exec -T php bin/console doctrine:migrations:list || true
                                docker compose -f compose.yaml -f compose.prod.yaml --env-file .env exec -T php bin/console dbal:run-sql "SELECT 1" || true
                                exit 1
                            fi
                        fi
                        
                        # Clear cache
                        docker compose -f compose.yaml -f compose.prod.yaml --env-file .env exec -T php bin/console cache:clear --no-warmup || true
                        
                        # Warmup cache
                        docker compose -f compose.yaml -f compose.prod.yaml --env-file .env exec -T php bin/console cache:warmup || true
                    fi
                    
                    # Test application health
                    sleep 3
                    docker compose -f compose.yaml -f compose.prod.yaml --env-file .env exec -T php php -v > /dev/null 2>&1 || true
                    
                    # Clean up old images
                    docker image prune -f
                    
                    # Show final status
                    docker compose -f compose.yaml -f compose.prod.yaml --env-file .env ps
                else
                    docker compose -f compose.yaml -f compose.prod.yaml --env-file .env logs php --tail 100
                    EXIT_CODE=$(docker inspect --format='{{.State.ExitCode}}' $PHP_CONTAINER 2>/dev/null || echo "unknown")
                    if [ -n "$CURRENT_CONTAINER" ] && docker ps -a --format '{{.ID}}' | grep -q "$CURRENT_CONTAINER"; then
                        docker compose -f compose.yaml -f compose.prod.yaml --env-file .env down
                        docker start $CURRENT_CONTAINER
                    else
                        docker compose -f compose.yaml -f compose.prod.yaml --env-file .env down
                    fi
                    exit 1
                fi
            else
                docker compose -f compose.yaml -f compose.prod.yaml --env-file .env ps -a
                docker compose -f compose.yaml -f compose.prod.yaml --env-file .env logs
                
                # Check if port 80 is the issue
                if command -v lsof >/dev/null 2>&1; then
                    lsof -i :80 2>/dev/null || true
                fi
                docker ps --filter "publish=80" || true
                
                docker ps -a --filter "name=joypharma" --format "{{.ID}}" | xargs -r docker stop 2>/dev/null || true
                docker ps -a --filter "name=joypharma" --format "{{.ID}}" | xargs -r docker rm 2>/dev/null || true
                
                exit 1
            fi
